/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package notCentipede;

/*
While (playX != foodX)
{
	Direction = foodX - playX > 0 ? 1 : -1;
	If (playX + direction != body)
	{
	move(direction);
        }
}
While (playY != foodY)
{
	Direction = foodY - playY > 0 ? 1 : -1;
	If (playY + (direction / 2) != body && playY + (direction / 2) < gird[0].length && playY + (direction / 2) > 0)
{
		move(direction);
}
}

*/
import com.sun.glass.events.KeyEvent;
import java.awt.AWTException;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Robot;
import java.awt.Toolkit;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

/**
 *
 * @author chhar9972
 */
public class notCentipede extends javax.swing.JFrame {
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    final int width = (int) screenSize.width;
    final int height = (int) screenSize.height;
    Color playColour = new Color(0, 0, 168), foodColour = new Color(255, 0, 0), snakeColour = new Color(252, 252, 84);
    int headX = 1, headY = 1, snakeLength = 1, tileSize, playX = 0, playY = 0, foodX = 0, foodY = 0, playAreaWidth, playAreaHeight;
    /**
     * Creates new form notCentipede
     */
    public notCentipede() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        labelPlaySize = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        labelHeadCords = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        labelDirection = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        labelFoodCords = new javax.swing.JLabel();
        status = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Snake Bot");
        setAlwaysOnTop(true);
        setResizable(false);

        jButton1.setText("Start bot");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setText("Play dimensions:");

        labelPlaySize.setText("NULL");

        jLabel5.setText("Head cords:");

        labelHeadCords.setText("NULL");

        jLabel2.setText("Direction:");

        labelDirection.setText("NULL");

        jLabel3.setText("Food cords:");

        labelFoodCords.setText("NULL");

        status.setText("Not started");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton1)
                    .addComponent(status))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelDirection)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelHeadCords))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelPlaySize)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelFoodCords)))
                .addContainerGap(150, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton1)
                    .addComponent(jLabel1)
                    .addComponent(labelPlaySize)
                    .addComponent(jLabel3)
                    .addComponent(labelFoodCords))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(labelDirection)
                    .addComponent(jLabel5)
                    .addComponent(labelHeadCords)
                    .addComponent(status))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        GamerThread gamer = new GamerThread();
        gamer.start();
    }//GEN-LAST:event_jButton1ActionPerformed
    public class GamerThread extends Thread
    {
        @Override
        public void run()
        {
            try 
            {
                Robot screenScanner = new Robot();
                //Waits untit the pixel in the center of the screen is the colour of the background
                status.setText("Waiting for snake game");
                //while (!colourEquals(screenScanner.getPixelColor(width / 2, height / 2), playColour))
                {
                }
                screenScanner.mouseMove(width / 2, height / 2);
                screenScanner.mousePress(InputEvent.BUTTON1_MASK);
                screenScanner.delay(100);
                screenScanner.mouseRelease(InputEvent.BUTTON1_MASK);
                screenScanner.mouseMove(0, 0);
                int searchAreaWidth = width, searchAreaHeight = height;
                Color pixelColour;
                BufferedImage screenShot = screenScanner.createScreenCapture(new Rectangle (screenSize));
                for (int x = 0; x < searchAreaWidth; x++)
                {
                    for (int y = playY; y < searchAreaHeight; y++)
                    {
                        pixelColour = new Color (screenShot.getRGB(x , y ));
                        if (foodX == 0 && colourEquals(pixelColour, foodColour))
                        {
                                //When the pixel colour is equal to the colour of the food
                                foodX = x;
                                foodY = y;
                                while(colourEquals(pixelColour, foodColour))
                                {
                                    //finds width by setting width until the snake colour ends
                                    tileSize = y - foodY;
                                    y ++;
                                    pixelColour = new Color (screenShot.getRGB(x , y ));
                                }
                                
                        }else if (playX == 0 && colourEquals(pixelColour, playColour))
                        {
                            //When the pixel colour is equal to the colour of the play area
                            playX = x;
                            playY = y;
                            while (colourEquals (pixelColour, playColour))
                            {
                                //Finds height until play area colour ends
                                playAreaHeight = y - playY;
                                searchAreaHeight = playAreaHeight;
                                y ++;
                                pixelColour = new Color (screenShot.getRGB(x , y ));
                            }
                            y --;
                            int tempX = x;
                            Color tempPixelColour = new Color (screenShot.getRGB(tempX , y ));
                            while (colourEquals(tempPixelColour, playColour))
                            {
                                //Finds width until play area colour ends
                                playAreaWidth = tempX - playX;
                                searchAreaWidth = playAreaWidth;
                                tempX ++;
                                tempPixelColour = new Color (screenShot.getRGB(tempX , y ));
                            }
                            y = playY;
                            x = playX;
                        }
                        if (foodX != 0 && playX != 0) break;
                    }
                }
                status.setText("Finished getting screen info");
                labelPlaySize.setText( playAreaWidth/tileSize - 1 + ", " + playAreaHeight/tileSize);
                labelFoodCords.setText(foodX + ", " + foodY);
                labelDirection.setText (Integer.toString(tileSize));
                playGame();
                //+ "  Head X: " + headX + "  Head Y: " + headY);
            } catch (AWTException ex) {
                System.out.println("OOF");
            }
        }
    
        public void playGame()
        {
            int direction = 0, tempDirection, prevDirection;
            int[][] grid = new int[playAreaWidth / tileSize][playAreaHeight / tileSize];
            Rectangle playArea = new Rectangle (playX, playY, playAreaWidth, playAreaHeight);
            BufferedImage screenShot, prevImage;
            try {
                Robot snakeBot = new Robot();
                screenShot = snakeBot.createScreenCapture(new Rectangle (0, 0, 1, 1));
                while (true)
                {
                    prevImage = screenShot;
                    screenShot = snakeBot.createScreenCapture(playArea);
                    if (!prevImage.equals(screenShot))
                    {
                        Color pixelColour;
                        for (int x = 0; x < grid.length; x++)
                        {
                            for (int y = 0; y < grid[0].length; y++)
                            {
                                pixelColour = new Color (screenShot.getRGB(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2));
                                if (colourEquals(pixelColour, foodColour))
                                {
                                    foodX = x;
                                    foodY = y;
                                }else if (colourEquals(pixelColour, snakeColour))
                                {
                                    if (grid[x][y] != 2)
                                    {
                                        headX = x;
                                        headY = y;
                                    }
                                    grid[x][y] = 2;
                                }else
                                {
                                    grid[x][y] = 0;
                                }
                            }
                        }
                        prevDirection = direction;
                        try
                        {
                            tempDirection = foodX - headX > 0 ? 1 : -1;
                            if (headX != foodX && grid[headX + tempDirection][headY] != 2) direction = foodX - headX > 0 ? 1 : -1;
                            tempDirection = foodY - headY > 0 ? 2 : -2;
                            if (headY != foodY && grid[headX + tempDirection / 2][headY] != 2) direction = foodY - headY > 0 ? 2 : -2;
                        }catch (ArrayIndexOutOfBoundsException offside)
                        {
                            
                        }
                        if (direction != prevDirection) move(direction);
                        
                        labelHeadCords.setText(headX + ", " + headY);
                        labelFoodCords.setText(foodX + ", " + foodY);
                        labelDirection.setText(direction + "");
                    }
                }

            } catch (AWTException ex) {
                System.out.println("OOF");
            }
            
        }
        
        public void move (int direction)
        {
            try {
                Robot move = new Robot();
                switch (direction) {
                    case 1:
                        move.keyPress(KeyEvent.VK_RIGHT);
                        move.delay(50);
                        move.keyRelease(KeyEvent.VK_RIGHT);
                        break;
                    case -1:
                        move.keyPress(KeyEvent.VK_LEFT);
                        move.delay(50);
                        move.keyRelease(KeyEvent.VK_LEFT);
                        break;
                    case 2:
                        move.keyPress(KeyEvent.VK_DOWN);
                        move.delay(50);
                        move.keyRelease(KeyEvent.VK_DOWN);
                        break;
                    case -2:
                        move.keyPress(KeyEvent.VK_UP);
                        move.delay(50);
                        move.keyRelease(KeyEvent.VK_UP);
                        break;
                    default:
                        break;
                }
            } catch (AWTException ex) {
                System.out.println("OOF");
            }           
        }
        public void log (String message)
        {
            System.out.println(message);
        }
    }
    public boolean colourEquals(Color c1, Color c2)
    {
        return c1.getRed() == c2.getRed() && c1.getBlue() == c2.getBlue() && c1.getGreen() == c2.getGreen();
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(notCentipede.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(notCentipede.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(notCentipede.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(notCentipede.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new notCentipede().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel labelDirection;
    private javax.swing.JLabel labelFoodCords;
    private javax.swing.JLabel labelHeadCords;
    private javax.swing.JLabel labelPlaySize;
    private javax.swing.JLabel status;
    // End of variables declaration//GEN-END:variables
}
